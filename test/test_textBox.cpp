/*!
 * @brief Test suite for the duckx::TextBox class.
 *
 * @author LiuYe
 * @date 2025.07.05
 * @copyright (c) 2013-2025 Honghu Yuntu Corporation
 */
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "TextBox.hpp"
#include "DrawingElement.hpp"
#include "BaseElement.hpp"
#include <string>
#include <vector>

class TextBoxTest : public ::testing::Test
{
protected:
    pugi::xml_document doc;
    pugi::xml_node parent_run_node;

    void SetUp() override
    {
        // Create a dummy parent run node (<w:r>) as it would exist in a real document.
        // The <w:drawing> element generated by TextBox will be a child of this node.
        parent_run_node = doc.append_child("w:r");
    }

    // Helper to verify the existence of a specific XML path from a starting node.
    // Example path: {"w:drawing", "wp:inline", "wp:extent"}
    static bool has_xml_path(const pugi::xml_node start_node, const std::vector<std::string>& path)
    {
        pugi::xml_node current = start_node;
        for (const auto& name: path)
        {
            current = current.child(name.c_str());
            if (!current)
            {
                return false;
            }
        }
        return true;
    }
};

// ============================================================================
// Constructor Tests
// ============================================================================

TEST_F(TextBoxTest, DefaultConstructor_InitialStateIsEmptyAndNoBorder)
{
    const duckx::TextBox tb;

    // A default-constructed textbox should be empty.
    const auto paragraphs = tb.paragraphs();
    EXPECT_TRUE(paragraphs.empty());
    EXPECT_EQ(paragraphs.size(), 0);

    // Generate the XML to verify its structure.
    tb.generate_drawing_xml(parent_run_node, "rId1", 1);

    // Verify the basic drawing structure exists.
    ASSERT_TRUE(parent_run_node.child("w:drawing"));
    const pugi::xml_node drawing_node = parent_run_node.child("w:drawing");

    // Default should be an inline shape.
    ASSERT_TRUE(drawing_node.child("wp:inline"));
    const pugi::xml_node shape_properties_node = drawing_node.select_node("//wps:spPr").node();
    ASSERT_TRUE(shape_properties_node);

    // Default should have no border, which is represented by <a:noFill> and the absence of <a:ln>.
    EXPECT_TRUE(shape_properties_node.child("a:noFill"));
    EXPECT_FALSE(shape_properties_node.child("a:ln"));
}

TEST_F(TextBoxTest, ConstructorWithBorder_InitialStateIsEmptyAndHasBorder)
{
    const duckx::TextBox tb(duckx::BorderStyle::SOLID);

    // The textbox should still be empty of content.
    EXPECT_TRUE(tb.paragraphs().empty());

    // Generate XML to verify the border.
    tb.generate_drawing_xml(parent_run_node, "rId2", 2);

    const pugi::xml_node shape_properties_node = parent_run_node.select_node("//wps:spPr").node();
    ASSERT_TRUE(shape_properties_node);

    // A solid border requires a line element <a:ln>.
    const pugi::xml_node line_properties_node = shape_properties_node.child("a:ln");
    ASSERT_TRUE(line_properties_node);
    // It should contain a fill style, e.g., <a:solidFill>.
    ASSERT_TRUE(line_properties_node.child("a:solidFill"));
}

// ============================================================================
// Member Function Tests
// ============================================================================

TEST_F(TextBoxTest, SetBorder_CorrectlyChangesXML)
{
    duckx::TextBox tb; // Default is BorderStyle::NONE

    // Change to SOLID and verify.
    tb.set_border(duckx::BorderStyle::SOLID);
    tb.generate_drawing_xml(parent_run_node, "rId3", 3);
    const pugi::xml_node shape_props_solid = parent_run_node.select_node("//wps:spPr").node();
    ASSERT_TRUE(shape_props_solid);
    EXPECT_TRUE(shape_props_solid.child("a:ln"));

    // Change back to NONE and verify.
    tb.set_border(duckx::BorderStyle::NONE);
    pugi::xml_document new_doc;
    const pugi::xml_node new_parent = new_doc.append_child("w:r");
    tb.generate_drawing_xml(new_parent, "rId4", 4);
    const pugi::xml_node shape_props_none = new_parent.select_node("//wps:spPr").node();
    ASSERT_TRUE(shape_props_none);
    EXPECT_FALSE(shape_props_none.child("a:ln"));
}

TEST_F(TextBoxTest, AddParagraph_AddsContentAndReturnsValidParagraph)
{
    const duckx::TextBox tb;
    const duckx::Paragraph p = tb.add_paragraph("Hello, TextBox!");

    // Test the returned paragraph object.
    ASSERT_TRUE(p.get_node());
    EXPECT_EQ(p.runs().begin()->get_text(), "Hello, TextBox!");

    // Test the internal state via the paragraphs() range.
    auto paragraphs = tb.paragraphs();
    ASSERT_FALSE(paragraphs.empty());
    EXPECT_EQ(paragraphs.size(), 1);

    auto it = paragraphs.begin();
    auto runs = it->runs();
    ASSERT_FALSE(runs.empty());
    EXPECT_EQ(runs.begin()->get_text(), "Hello, TextBox!");

    // Verify XML generation includes the paragraph.
    tb.generate_drawing_xml(parent_run_node, "rId5", 5);
    const pugi::xml_node txbx_content = parent_run_node.select_node("//w:txbxContent").node();
    ASSERT_TRUE(txbx_content);
    const pugi::xml_node para_node = txbx_content.child("w:p");
    ASSERT_TRUE(para_node);
    EXPECT_STREQ(para_node.child("w:r").child("w:t").child_value(), "Hello, TextBox!");
}

TEST_F(TextBoxTest, AddMultipleParagraphs_MaintainsOrderAndContent)
{
    const duckx::TextBox tb;
    (void)tb.add_paragraph("First paragraph.");
    (void)tb.add_paragraph("Second paragraph.");

    auto paragraphs = tb.paragraphs();
    ASSERT_EQ(paragraphs.size(), 2);

    auto it = paragraphs.begin();
    EXPECT_EQ(it->runs().begin()->get_text(), "First paragraph.");
    ++it;
    ASSERT_NE(it, paragraphs.end());
    EXPECT_EQ(it->runs().begin()->get_text(), "Second paragraph.");
}

TEST_F(TextBoxTest, AddNewParagraph_AddsContentCorrectly)
{
    const duckx::TextBox tb;
    tb.add_new_paragraph("This is a void-return paragraph.");

    auto paragraphs = tb.paragraphs();
    ASSERT_EQ(paragraphs.size(), 1);
    EXPECT_EQ(paragraphs.begin()->runs().begin()->get_text(), "This is a void-return paragraph.");
}

TEST_F(TextBoxTest, LastParagraph_ReturnsCorrectParagraph)
{
    const duckx::TextBox tb;
    (void)tb.add_paragraph("First");
    (void)tb.add_paragraph("Second");
    (void)tb.add_paragraph("Last");

    const duckx::Paragraph retrieved_last = tb.last_paragraph();
    ASSERT_TRUE(retrieved_last.get_node());
    EXPECT_EQ(retrieved_last.runs().begin()->get_text(), "Last");
}

TEST_F(TextBoxTest, LastParagraph_OnEmptyTextBoxReturnsInvalid)
{
    const duckx::TextBox tb;
    const duckx::Paragraph p = tb.last_paragraph();
    // Expect an invalid paragraph object (with a null node).
    EXPECT_FALSE(p.get_node());
}

TEST_F(TextBoxTest, SetSizeAndPosition_GeneratesAnchorXML)
{
    duckx::TextBox tb;
    tb.set_size(200, 100);
    // 1 inch = 914400 EMUs. Position is (1 inch, 2 inches).
    tb.set_absolute_position(914400, 1828800);

    tb.generate_drawing_xml(parent_run_node, "rId6", 6);

    // Setting position requires an <wp:anchor> element.
    const pugi::xml_node anchor_node = parent_run_node.child("w:drawing").child("wp:anchor");
    ASSERT_TRUE(anchor_node);

    // Check extent (size in EMUs), assuming 96 DPI (1px = 9525 EMU)
    const pugi::xml_node extent_node = anchor_node.child("wp:extent");
    ASSERT_TRUE(extent_node);
    EXPECT_STREQ(extent_node.attribute("cx").value(), "1905000"); // 200px * 9525
    EXPECT_STREQ(extent_node.attribute("cy").value(), "952500"); // 100px * 9525

    // Check position offset.
    const pugi::xml_node pos_h = anchor_node.child("wp:positionH").child("wp:posOffset");
    ASSERT_TRUE(pos_h);
    EXPECT_STREQ(pos_h.child_value(), "914400");

    const pugi::xml_node pos_v = anchor_node.child("wp:positionV").child("wp:posOffset");
    ASSERT_TRUE(pos_v);
    EXPECT_STREQ(pos_v.child_value(), "1828800");
}

TEST_F(TextBoxTest, GenerateDrawingXML_CopiesParagraphFormatting)
{
    const duckx::TextBox tb;
    // Add a paragraph with formatting.
    (void)tb.add_paragraph("Formatted text", duckx::bold | duckx::italic);

    tb.generate_drawing_xml(parent_run_node, "rId7", 7);

    // Verify the text content.
    const pugi::xml_node text_node = parent_run_node.select_node("//w:t").node();
    ASSERT_TRUE(text_node);
    EXPECT_STREQ(text_node.child_value(), "Formatted text");

    // Verify the formatting properties exist in the run properties (<w:rPr>).
    const pugi::xml_node rpr_node = text_node.parent().child("w:rPr");
    ASSERT_TRUE(rpr_node);
    EXPECT_TRUE(rpr_node.child("w:b"));
    EXPECT_TRUE(rpr_node.child("w:i"));
    EXPECT_FALSE(rpr_node.child("w:u")); // Should not have underline.
}

TEST_F(TextBoxTest, AddParagraph_ClearsInitialEmptyParagraphNode)
{
    const duckx::TextBox tb;

    // The internal XML document starts with a <w:p/> node to be valid.
    // The first call to add_paragraph should replace it.
    (void)tb.add_paragraph("First real paragraph");

    // A second paragraph should be appended.
    (void)tb.add_paragraph("Second real paragraph");

    tb.generate_drawing_xml(parent_run_node, "rId8", 8);

    const pugi::xml_node txbx_content = parent_run_node.select_node("//w:txbxContent").node();
    ASSERT_TRUE(txbx_content);

    // There should be exactly two paragraphs.
    size_t p_count = std::distance(txbx_content.children("w:p").begin(), txbx_content.children("w:p").end());
    EXPECT_EQ(p_count, 2);

    // Check content to be sure.
    EXPECT_STREQ(txbx_content.child("w:p").child("w:r").child("w:t").child_value(), "First real paragraph");
    EXPECT_STREQ(txbx_content.child("w:p").next_sibling("w:p").child("w:r").child("w:t").child_value(),
                 "Second real paragraph");
}
